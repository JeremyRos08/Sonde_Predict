"""
simulation.py

Moteur de simulation principal de Sonde_Predict.

- Descente seule (objet / parachute)
- Vol complet ballon : montée → burst / rupture → descente
- Gestion chute libre physique
- Vent dépendant de l’altitude

Modèle simple, robuste et lisible.

PATCH perf + impact :
- Arrêt net à l’impact via dt_to_ground (pas de states jusqu’à 0)
- Altitude sol via OpenTopoData avec cache + mise à jour espacée (sinon freeze)
- Requête sol “verrouillage” uniquement au moment de l’impact
"""

from __future__ import annotations

import math
import requests
from dataclasses import dataclass
from typing import List

from App.profiles import DescentProfile, AscentProfile, WindProfile

# ============================================================
# CONSTANTES
# ============================================================

EARTH_RADIUS_M = 6_371_000.0
G = 9.81
# RHO0 = 1.225  # kg/m³  # densité air au sol (référence ISA)

# ============================================================
# STRUCTURE D'ÉTAT
# ============================================================

@dataclass
class State:
    t_s: float
    alt_m: float
    lat_deg: float
    lon_deg: float
    descent_ms: float
    wind_u_ms: float
    wind_v_ms: float
    area_factor: float | None = None
    mass: float | None = None
    phase: str = "DESCENT"   # ASCENT | DESCENT | FREE_FALL
    rupture: bool = False
    is_burst: bool = False
    alt_ground: float | None = None


def wind_coupling_factor(alt_m: float) -> float:
    if alt_m < 18000:
        return 1.0
    elif alt_m > 32000:
        return 0.35
    else:
        return 1.0 - (alt_m - 18000) / (32000 - 18000) * 0.65
# ============================================================
# PAS DE TEMPS ADAPTATIF
# ============================================================

def compute_dt(dt_base: float, alt: float, phase: str, v_vert: float, wind_u: float, wind_v: float) -> float:
    dt_base = max(float(dt_base), 0.2)

    # --- cap "altitude" (ta logique actuelle, OK) ---
    if phase == "ASCENT":
        cap_alt = 2.0
    else:
        if alt >= 18000:
            cap_alt = 2.0
        elif alt <= 1000:
            cap_alt = 10.0
        else:
            cap_alt = 2.0 + (10.0 - 2.0) * (1.0 - (alt - 1000.0) / (18000.0 - 1000.0))

    dt = min(dt_base, cap_alt)

    # --- cap vertical : max Δz par pas ---
    # règle: descente/parachute => 100m/step, montée => 150m/step, chute libre => 60m/step
    if phase == "FREE_FALL":
        dz_max = 60.0
    elif phase == "DESCENT":
        dz_max = 100.0
    else:
        dz_max = 150.0

    v = max(abs(v_vert), 1e-6)
    dt = min(dt, dz_max / v)

    # --- cap horizontal : max déplacement sol par pas ---
    # règle: max 250m/step (tu peux mettre 150 si tu veux très fin)
    dx_max = 250.0
    w = math.hypot(wind_u, wind_v)
    if w > 0.1:
        dt = min(dt, dx_max / w)

    return max(0.2, dt)


# ============================================================
# DENSITÉ AIR (CHUTE LIBRE)
# ============================================================

def air_density_table(alt_max_m: int = 35000, step_m: int = 100) -> dict[int, float]:
    table = {}
    for alt in range(0, alt_max_m + step_m, step_m):
        if alt < 11000:
            rho = 1.225 * (1 - 2.25577e-5 * alt) ** 4.256
        else:
            rho = 0.36391 * math.exp(-(alt - 11000) / 6341)
        table[alt] = rho
    return table

def air_density_from_table(alt_m: float, table: dict[int, float]) -> float:
    key = int(round(alt_m / 100.0)) * 100
    return table.get(key, 0.02)

# ============================================================
# ALTITUDE SOL (CACHE + SESSION)
# ============================================================
def _cache_key(lat_deg: float, lon_deg: float, agl_m: float) -> tuple[float, float]:
    # Cache “adaptatif”
    if agl_m > 15000:
        r = 2        # ~1.1 km
    elif agl_m > 1500:
        r = 3        # ~111 m
    else:
        r = 4        # ~11 m
    return (round(lat_deg, r), round(lon_deg, r))


_session = requests.Session()
_ground_cache: dict[tuple[float, float], float] = {}
_last_alt_ground = 0.0


def ground_altitude_point(lat_deg: float, lon_deg: float, agl_m: float) -> float:
    """1 point + cache (rapide et cohérent)."""
    global _last_alt_ground

    key = _cache_key(lat_deg, lon_deg, agl_m)
    if key in _ground_cache:
        return _ground_cache[key]

    alt = _last_alt_ground
    try:
        DATASET = "eudem25m,srtm90m"
        INTERP = "cubic"
        url = f"https://api.opentopodata.org/v1/{DATASET}?locations={lat_deg},{lon_deg}&interpolation={INTERP}"
        resp = _session.get(url, timeout=3)
        resp.raise_for_status()
        data = resp.json()
        alt = float(data["results"][0]["elevation"])
    except Exception:
        alt = _last_alt_ground

    _ground_cache[key] = alt
    _last_alt_ground = alt
    return alt


def ground_altitude_impact(lat_deg: float, lon_deg: float) -> float:
    """
    Sol robuste à l’impact : médiane 5 points (1 seule requête).
    À utiliser UNIQUEMENT au verrouillage IMPACT.
    """
    global _last_alt_ground

    d = 0.00015  # ~16 m
    pts = [
        (lat_deg, lon_deg),
        (lat_deg + d, lon_deg),
        (lat_deg - d, lon_deg),
        (lat_deg, lon_deg + d),
        (lat_deg, lon_deg - d),
    ]
    locations = "|".join(f"{la},{lo}" for la, lo in pts)

    try:
        DATASET = "eudem25m,srtm90m"
        INTERP = "nearest"
        url = f"https://api.opentopodata.org/v1/{DATASET}?locations={locations}&interpolation={INTERP}"
        resp = _session.get(url, timeout=3)
        resp.raise_for_status()
        data = resp.json()
        elevs = [float(res["elevation"]) for res in data["results"] if res.get("elevation") is not None]
        if not elevs:
            return _last_alt_ground
        elevs.sort()
        alt = elevs[len(elevs)//2]
        _last_alt_ground = alt
        return alt
    except Exception:
        return _last_alt_ground

def should_update_ground(lat1_deg: float, lon1_deg: float, lat2_deg: float, lon2_deg: float, agl_m: float) -> bool:
    """
    Met à jour le sol seulement si on a bougé “assez”.
    Seuil plus fin près du sol.
    """
    if agl_m >= 8000:
        return False
    # 0.001° ~ 111 m (lat). 0.0002° ~ 22 m.
    if agl_m < 1500:
        thr = 0.0008 # 90m
    elif agl_m < 6000:
        thr = 0.0020 # 220m
    else:
        thr = 0.0050 # 1km
    return abs(lat2_deg - lat1_deg) > thr or abs(lon2_deg - lon1_deg) > thr

# ============================================================
# DESCENTE SEULE
# ============================================================

def simulate_descent(
    alt0_m: float,
    lat0_deg: float,
    lon0_deg: float,
    dt_s: float,
    descent_profile: DescentProfile,
    wind_profile: WindProfile,
    max_steps: int = 40000,
) -> List[State]:

    states: List[State] = []

    t = 0.0
    alt = float(alt0_m)
    lat = math.radians(lat0_deg)
    lon = math.radians(lon0_deg)

    lat_deg = math.degrees(lat)
    lon_deg = math.degrees(lon)
    alt_ground = ground_altitude_point(lat_deg, lon_deg, 0.0)
    lat_last = lat_deg
    lon_last = lon_deg

    # état initial
    wind_u0, wind_v0 = wind_profile.value(alt)

    states.append(State(
        t_s=t,
        alt_m=alt,
        lat_deg=lat0_deg,
        lon_deg=lon0_deg,
        descent_ms=0.0,
        wind_u_ms=wind_u0,
        wind_v_ms=wind_v0,
        phase="DESCENT",
        rupture=False,
        is_burst=False,
        alt_ground=alt_ground,
    ))

    for _ in range(max_steps):
        # coords courantes
        lat_deg = math.degrees(lat)
        lon_deg = math.degrees(lon)

        # sol (espacé)
        agl = max(0.0, alt - alt_ground)
        if should_update_ground(lat_last, lon_last, lat_deg, lon_deg, agl):
            alt_ground = ground_altitude_point(lat_deg, lon_deg, agl)
            lat_last = lat_deg
            lon_last = lon_deg
            agl = max(0.0, alt - alt_ground)

        # impact check
        h_remain = alt - alt_ground
        if h_remain <= 0:
            states.append(State(t, alt_ground, lat_deg, lon_deg, 0.0, 0.0, 0.0, phase="IMPACT", alt_ground=alt_ground))
            break

        # paramètres
        v_vert = descent_profile.value(alt)
        wind_u0, wind_v0 = wind_profile.value(alt)

        dt = compute_dt(dt_s, alt, "DESCENT", v_vert, wind_u0, wind_v0)
        dt_to_ground = h_remain / max(v_vert, 1e-6)
        will_impact = dt_to_ground <= dt
        if will_impact:
            dt = dt_to_ground

         # intégration vent cohérente
        u0, v0 = wind_profile.value(alt)
        u1, v1 = wind_profile.value(alt + v_vert * dt)

        f0 = wind_coupling_factor(alt)
        f1 = wind_coupling_factor(alt - v_vert * dt)

        u0 *= f0
        v0 *= f0
        u1 *= f1
        v1 *= f1

        u = 0.5 * (u0 + u1)
        v = 0.5 * (v0 + v1)        

        # intégration
        alt -= v_vert * dt
        lat += (v * dt) / EARTH_RADIUS_M
        lon += (u * dt) / (EARTH_RADIUS_M * math.cos(lat))
        t += dt

        lat_deg = math.degrees(lat)
        lon_deg = math.degrees(lon)


        states.append(State(
            t_s=t,
            alt_m=alt,
            lat_deg=lat_deg,
            lon_deg=lon_deg,
            descent_ms=v_vert,
            wind_u_ms=u,
            wind_v_ms=v,
            phase="DESCENT",
            alt_ground=alt_ground,
        ))

        if will_impact:
            # verrouillage sol au point final
            alt_ground = ground_altitude_impact(lat_deg, lon_deg)
            alt = alt_ground
            states.append(State(
                t_s=t,
                alt_m=alt,
                lat_deg=lat_deg,
                lon_deg=lon_deg,
                descent_ms=0.0,
                wind_u_ms=0.0,
                wind_v_ms=0.0,
                phase="IMPACT",
                alt_ground=alt_ground,
            ))
            break

    return states

# ============================================================
# VOL COMPLET : montée -> burst -> descente (+ chute libre)
# ============================================================

def simulate_flight(
    alt_start_m: float,
    alt_burst_m: float,
    lat0_deg: float,
    lon0_deg: float,
    dt_s: float,
    ascent_profile: AscentProfile,
    descent_profile: DescentProfile,
    wind_profile: WindProfile,
    area_factor: float | None=None,
    mass: float | None=None,
    *,
    ff_start_alt: float | None=None,
    ff_mode: str | None=None,   # "before_burst" | "after_burst" | None
    max_steps: int = 60000,
) -> List[State]:

    states: List[State] = []
    rho_table = air_density_table()

    t = 0.0
    alt = float(alt_start_m)
    lat = math.radians(lat0_deg)
    lon = math.radians(lon0_deg)

    phase = "ASCENT"
    rupture_ff = False
    burst_allowed = True

    lat_deg = math.degrees(lat)
    lon_deg = math.degrees(lon)
    alt_ground = ground_altitude_point(lat_deg, lon_deg, 0.0)
    lat_last = lat_deg
    lon_last = lon_deg

    # état initial
    wind_u0, wind_v0 = wind_profile.value(alt)

    states.append(State(
        t_s=t,
        alt_m=alt,
        lat_deg=lat0_deg,
        lon_deg=lon0_deg,
        descent_ms=0.0,
        wind_u_ms=wind_u0,
        wind_v_ms=wind_v0,
        phase="ASCENT",
        rupture=False,
        is_burst=False,
        alt_ground=alt_ground,
    ))

    # modèle chute libre (simple)

    af = area_factor if area_factor is not None else 1.0

    AREA_BASE = 0.015
    AREA_FREE = AREA_BASE * max(af, 0.1)
    CD_FREE = 1.0
     
    
    for _ in range(max_steps):
        lat_deg = math.degrees(lat)
        lon_deg = math.degrees(lon)

        # sol (update espacé seulement en descente/chute)
        if phase in ("DESCENT", "FREE_FALL"):
            agl = max(0.0, alt - alt_ground)
            if should_update_ground(lat_last, lon_last, lat_deg, lon_deg, agl):
                alt_ground = ground_altitude_point(lat_deg, lon_deg, agl)
                lat_last = lat_deg
                lon_last = lon_deg

        # ===========================
        # Déclenchement rupture/chute libre
        # ===========================
        if ff_start_alt is not None and not rupture_ff:
            if ff_mode == "before_burst" and phase == "ASCENT" and alt >= ff_start_alt:
                rupture_ff = True
                phase = "FREE_FALL"
                burst_allowed = False
            elif ff_mode == "after_burst" and phase == "DESCENT" and alt <= ff_start_alt:
                rupture_ff = True
                phase = "FREE_FALL"

            if rupture_ff:
                wind_u0, wind_v0 = wind_profile.value(alt)
                states.append(State(
                    t_s=t,
                    alt_m=alt,
                    lat_deg=lat_deg,
                    lon_deg=lon_deg,
                    descent_ms=0.0,
                    wind_u_ms=wind_u0,
                    wind_v_ms=wind_v0,
                    area_factor=area_factor,
                    mass=mass,
                    phase="FREE_FALL",
                    rupture=True,
                    alt_ground=alt_ground,
                ))
                # on passe au pas suivant, phase mise à jour
                continue

        # ===========================
        # ASCENT
        # ===========================
        if phase == "ASCENT":
            alt0 = alt
            v_vert = ascent_profile.value(alt0)

            wind_u0, wind_v0 = wind_profile.value(alt0)
            dt = compute_dt(dt_s, alt0, "ASCENT", v_vert, wind_u0, wind_v0)

            # intégration vent cohérente
            u0, v0 = wind_profile.value(alt0)
            u1, v1 = wind_profile.value(alt0 + v_vert * dt)

            f0 = wind_coupling_factor(alt0)
            f1 = wind_coupling_factor(alt0 - v_vert * dt)

            u0 *= f0
            v0 *= f0
            u1 *= f1
            v1 *= f1

            u = 0.5 * (u0 + u1)
            v = 0.5 * (v0 + v1)

            lat += (v * dt) / EARTH_RADIUS_M
            lon += (u * dt) / (EARTH_RADIUS_M * math.cos(lat))

            alt = alt0 + v_vert * dt
            t += dt

            # burst pendant ce pas ?
            if burst_allowed and alt0 + v_vert * dt >= alt_burst_m:
                dt_b = (alt_burst_m - alt0) / max(v_vert, 1e-6)
                dt_b = max(0.0, dt_b)

                lat_deg = math.degrees(lat)
                lon_deg = math.degrees(lon)
               
                t += dt_b

                alt = alt_burst_m

                # state burst (marqué is_burst=True et phase passe en DESCENT)
                states.append(State(
                    t_s=t,
                    alt_m=alt,
                    lat_deg=lat_deg,
                    lon_deg=lon_deg,
                    descent_ms=0.0,
                    wind_u_ms=u,
                    wind_v_ms=v,
                    mass=mass,
                    phase="DESCENT",
                    rupture=False,
                    is_burst=True,
                    alt_ground=alt_ground,
                ))

                phase = "DESCENT"
                continue



            states.append(State(
                t_s=t,
                alt_m=alt,
                lat_deg=math.degrees(lat),
                lon_deg=math.degrees(lon),
                descent_ms=0.0,
                wind_u_ms=u,
                wind_v_ms=v,
                mass=mass,
                phase="ASCENT",
                rupture=False,
                is_burst=False,
                alt_ground=alt_ground,
            ))
            continue

        # ===========================
        # DESCENT (parachute)
        # ===========================
        will_impact = False

        if phase == "DESCENT":
            alt0 = alt
            v_vert = descent_profile.value(alt0)

            wind_u0, wind_v0 = wind_profile.value(alt0)
            dt = compute_dt(dt_s, alt0, "DESCENT", v_vert, wind_u0, wind_v0)
            dt = min(dt, alt0 / max(v_vert, 1e-6))

            # prévision impact
            h_remain = alt0 - alt_ground
            dt_to_ground = h_remain / max(v_vert, 1e-6)
            will_impact = dt_to_ground <= dt
            if will_impact:
                dt = dt_to_ground

            # intégration vent PROPRE
            u0, v0 = wind_profile.value(alt0)
            u1, v1 = wind_profile.value(alt0 + v_vert * dt)

            f0 = wind_coupling_factor(alt0)
            f1 = wind_coupling_factor(alt0 - v_vert * dt)

            u0 *= f0
            v0 *= f0
            u1 *= f1
            v1 *= f1

            u = 0.5 * (u0 + u1)
            v = 0.5 * (v0 + v1)

            lat += (v * dt) / EARTH_RADIUS_M
            lon += (u * dt) / (EARTH_RADIUS_M * math.cos(lat))

            alt = alt0 + v_vert * dt
            t += dt

            lat_deg = math.degrees(lat)
            lon_deg = math.degrees(lon)

        
            states.append(State(
                t_s=t,
                alt_m=alt,
                lat_deg=lat_deg,
                lon_deg=lon_deg,
                descent_ms=v_vert,
                wind_u_ms=u,
                wind_v_ms=v,
                area_factor=area_factor,
                mass=mass,
                phase="DESCENT",
                rupture=False,
                is_burst=False,
                alt_ground=alt_ground,
            ))

            if will_impact:
                alt_ground = ground_altitude_impact(lat_deg, lon_deg)
                alt = alt_ground
                states.append(State(
                    t_s=t,
                    alt_m=alt,
                    lat_deg=lat_deg,
                    lon_deg=lon_deg,
                    descent_ms=0.0,
                    wind_u_ms=0.0,
                    wind_v_ms=0.0,
                    area_factor=area_factor,
                    mass=mass,
                    phase="IMPACT",
                    rupture=False,
                    is_burst=False,
                    alt_ground=alt_ground,
                ))
                break

            continue

        # ===========================
        # FREE_FALL
        # ===========================
        if phase == "FREE_FALL":
            alt0 = alt
            rho = air_density_from_table(alt0, rho_table)

            v_vert = math.sqrt((2 * mass * G) / (max(rho, 1e-6) * CD_FREE * AREA_FREE))
            v_vert = min(v_vert, 120.0)

            wind_u0, wind_v0 = wind_profile.value(alt0)
            dt = compute_dt(dt_s, alt0, "FREE_FALL", v_vert, wind_u0, wind_v0)

            # impact prediction
            h_remain = alt0 - alt_ground
            dt_to_ground = h_remain / max(v_vert, 1e-6)
            will_impact = dt_to_ground <= dt
            if will_impact:
                dt = dt_to_ground

            # vent intégré propre
            u0, v0 = wind_profile.value(alt0)
            u1, v1 = wind_profile.value(alt0 + v_vert * dt)

            f0 = wind_coupling_factor(alt0)
            f1 = wind_coupling_factor(alt0 - v_vert * dt)

            u0 *= f0
            v0 *= f0
            u1 *= f1
            v1 *= f1

            u = 0.5 * (u0 + u1)
            v = 0.5 * (v0 + v1)

            # intégration
            lat += (v * dt) / EARTH_RADIUS_M
            lon += (u * dt) / (EARTH_RADIUS_M * math.cos(lat))
            alt = alt0 - v_vert * dt
            t += dt

            lat_deg = math.degrees(lat)
            lon_deg = math.degrees(lon)

            if will_impact:
                alt_ground = ground_altitude_impact(lat_deg, lon_deg)
                alt = alt_ground
                states.append(State(
                    t_s=t,
                    alt_m=alt,
                    lat_deg=lat_deg,
                    lon_deg=lon_deg,
                    descent_ms=0.0,
                    wind_u_ms=0.0,
                    wind_v_ms=0.0,
                    area_factor=area_factor,
                    mass=mass,
                    phase="IMPACT",
                    rupture=True,
                    alt_ground=alt_ground,
                ))
                break

            states.append(State(
                t_s=t,
                alt_m=alt,
                lat_deg=lat_deg,
                lon_deg=lon_deg,
                descent_ms=v_vert,
                wind_u_ms=u,
                wind_v_ms=v,
                area_factor=area_factor,
                mass=mass,
                phase="FREE_FALL",
                rupture=True,
                alt_ground=alt_ground,
            ))
            continue


    return states
